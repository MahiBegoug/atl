<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-
transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
	<link rel="stylesheet" href="../style.css" charset="ISO-8859-1" type="text/css"/>
	<title>ATL Help</title>
</head>

<body>
<h1>ATL tutorial</h1>
<p>
We will explain you here how to create an ATL file, and how you can use the ATL syntax to define your 
transformations. The <a href="structure.html">structure concept</a> is an help you should use before beginning your ATL development. Here we show you 
the way to transform a <a href="../img/MetaModelJava.png">Java model</a> from an UML one of Java.</p>

<h2><a name="createFile"></a>Creating an ATL file</h2>
<p>
The only way for now to create an ATL file is via the menu "File &gt; New &gt; File ...". In the popup window, 
you fill the name of your ATL file following by the ".atl" extension.
</p>
<p>
The basic <a href="structure.html">structure</a> of the file has to be defined by yourself from your knowledges.
Besides, we proprose you to do this tutorial with a simple transformation of a Java meta-model archived <a href="
uml2java.zip">here</a>.
</p>

<h2><a name="package"></a>Package transformation</h2>
<p>Packages transformation needs a simple rule and an helper. We want to build a full Java package name, that 
means concatenate every short name of the packages since from the root of the tree. This is the reason why we use 
the helper <em>getExtendedName()</em> to fetch it. This value will be stored in the <em>name</em> attribute of the 
resulting model.</p>
<p>As a consequence of conflicts between UML packages and UML models, we have to specify that the ingoing model is 
of type UML!Package. We do this with an OCL expression, <em>oclIsTypeOf</em>, which checks the type of the
given variable, here <em>e</em>.</p>
<pre class="code">
rule P2P {
	from e : UML!Package (e.oclIsTypeOf(UML!Package))
	to out : JAVA!Package (
		name <- e.getExtendedName()
	)
}
</pre>
<p>We already described what we intended to do with this helper. For that we use the <em>UML!Namespace</em> 
context and want to return a <em>String</em>. This is a recursive helper that concatenates the name of the parent 
package with the current one. To stop the recursion, we check the namespace is undefined or of type <em>UML!
Model</em>.</p>
<pre class="code">
helper context UML!Namespace def: getExtendedName() : String =
	if self.namespace.oclIsUndefined() then
		''
	else if self.namespace.oclIsKindOf(UML!Model) then
		''
	else
		self.namespace.getExtendedName() + '.'
	endif endif + self.name;
</pre>

<h2><a name="class"></a>Class transformation</h2>
<p>To transform a Java class, the basics are the <em>name</em>, <em>package</em> and <em>abstract</em> attributes 
that just needs to fetch simple attribute in the ingoing model.</p>
<p>Here we get a new helper, <em>isPublic</em>, that informs when an element is public by matching its visibility 
with the literal <em>#vk_public</em>.</p>
<pre class="code">
rule C2C {
	from e : UML!Class
	to out : JAVA!JavaClass (
		name <- e.name,
		isAbstract <- e.isAbstract,
		isPublic <- e.isPublic(),
		package <- e.namespace
	)
}

helper context UML!ModelElement def: isPublic() : Boolean =
	self.visibility = #vk_public;
</pre>

<h2><a name="type"></a>Primitive type transformation</h2>
<p>The primitive type transformation is still simpler because we just have to set the <em>name</em> and <em>
package</em> attributes.</p>
<pre class="code">
rule D2P {
	from e : UML!DataType
	to out : JAVA!PrimitiveType (
		name <- e.name,
		package <- e.namespace
	)
}
</pre>

<h2><a name="field"></a>Field transformation</h2>
<p>Except the attributes we have already seen in <a href="#class">other transformations</a>, new simple attributes 
appear and two new heplers too.</p>
<pre class="code">
rule A2F {
	from e : UML!Attribute
	to out : JAVA!Field (
		name <- e.name,
		isStatic <- e.isStatic(),
		isPublic <- e.isPublic(),
		isFinal <- e.isFinal(),
		owner <- e.owner,
		type <- e.type
	)
}
</pre>
<p>As for the <em>isPublic</em> <a href="#class">helper</a>, these two helpers look at a literal. The <em>isStatic 
</em> helper tries to match its <em>ownerScope</em> attribute with the literal <em>#sk_static</em> to check if the 
current feature is a static one.</p>
<pre class="code">
helper context UML!Feature def: isStatic() : Boolean =
	self.ownerScope = #sk_static;
</pre>
<p>Like the <em>isStatic</em> helper, the <em>isFinal</em> helper tries to match its <em>changeability</em> attribute 
with the literal <em>#ck_frozen</em>.</p>
<pre class="code">
helper context UML!Attribute def: isFinal() : Boolean =
	self.changeability = #ck_frozen;
</pre>

<h2><a name="method"></a>Method transformation</h2>
<p>In this rule, we transform methods. Thus we set the current attributes, and new ones need OCL expressions.</p>
<p>The <em>type</em> attribute is setting by collecting all parameters, selecting only ones that have a kind 
matching the literal <em>#pdk_return</em>. As it should exist only one instance, it is necessary to cast as a 
sequence, gets the first element (that, we repeat, should be the only one !) and at last gets the type.</p>
<p>The <em>parameters</em> is something similar. We collect the parameters matching only ones that  kind differ 
with the literal <em>#pdk_return</em>, and thus return the collection casting as a sequence.</p>
<pre class="code">
rule O2M {
	from e : UML!Operation
	to out : JAVA!Method (
		name <- e.name,
		isStatic <- e.isStatic(),
		isPublic <- e.isPublic(),
		owner <- e.owner,
		type <- e.parameter->select(x | x.kind = #pdk_return)->asSequence()->first().type,
		parameters <- e.parameter->select(x | x.kind <> #pdk_return)->asSequence()
	)
}
</pre>

<h2><a name="parameter"></a>Feature parameter transformation</h2>
<p>This rule is not very hard to understand. Except the simple attributes, we have to think about ingoing variable 
which kind should be different than the literal <em>#pdk_return</em>. This is because we don't want to have a 
rueturn parameter that is a special one.</p>
<pre class="code">
rule P2F {
	from e : UML!Parameter (e.kind <> #pdk_return)
	to out : JAVA!FeatureParameter (
		name <- e.name,
		type <- e.type
	)
}
</pre>

</body>
</html>
