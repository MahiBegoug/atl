-- @atlcompiler emftvm
-- @nsURI EMFTVM=http://www.eclipse.org/m2m/atl/2011/EMFTVM
-- @path ATL=/org.eclipse.m2m.atl.emftvm.compiler/metamodels/ATL.ecore
-- @path Problem=/org.eclipse.m2m.atl.emftvm.compiler/metamodels/Problem.ecore
-- Transforms ATL modules into EMFTVM modules
-- $Id: ATLtoEMFTVM.atl,v 1.7 2011/11/09 10:23:17 dwagelaar Exp $
module ATLtoEMFTVM;

create OUT : EMFTVM, PBS : Problem from IN : ATL;

uses OCLtoEMFTVM;

-- ======================================================================
-- helpers begin
-- ======================================================================

helper context ATL!CalledRule def : isStatic : String =
	true;

helper context ATL!OutPatternElement def : outModelName : String =
	if self.model.oclIsUndefined() then
		self.outPattern."rule"."module".outModels
		->select(m|self.type.modelName = m.metamodel.name)
		->first().name
	else
		self.model.name
	endif;

helper context ATL!MatchedRule def : defaultInElement : ATL!InPatternElement =
	self.inPattern.elements->first();

helper context ATL!Rule def : defaultInElement : ATL!InPatternElement =
	OclUndefined;

helper context ATL!VariableExp def : localVariable() : EMFTVM!LocalVariable =
	let var : ATL!VariableDeclaration = self.referredVariable in
	if var.isMatchedRuleElement then
		if self.isInApply then
			thisModule.resolveTemp(var, 'ov')
		else if self.isInPostApply then
			thisModule.resolveTemp(var, 'pv')
		else
			thisModule.resolveTemp(var, 'lv')
		endif endif
	else
		thisModule.resolveTemp(var, 'lv')
	endif;

helper context ATL!VariableDeclaration def : isMatchedRuleElement : Boolean =
	if self.oclIsKindOf(ATL!PatternElement) or self.oclIsKindOf(ATL!RuleVariableDeclaration) then
		self.parentRule.oclIsKindOf(ATL!MatchedRule)
	else false endif;

helper context ATL!RuleVariableDeclaration def : isMatchedRuleField : Boolean =
	self.parentRule.oclIsKindOf(ATL!MatchedRule);

helper context OclAny def : parentRule : ATL!Rule =
	let parent : OclAny = self.refImmediateComposite() in
	if parent.oclIsKindOf(ATL!Rule) then parent
	else if not parent.oclIsUndefined() then parent.parentRule
	else self.debug('parent rule not found for')
	endif endif;

helper context ATL!VariableExp def : traceVariable() : EMFTVM!LocalVariable =
	let var : ATL!VariableDeclaration = self.referredVariable in
	if var.oclIsKindOf(ATL!RuleVariableDeclaration) then
		let r : ATL!Rule = var."rule" in
		if self.isInApply then
			thisModule.resolveTemp(r, 'a_trace')
		else if self.isInPostApply then
			thisModule.resolveTemp(r, 'p_trace')
		else
			OclUndefined.debug('Cannot access trace local variable from outside apply or post-apply')
		endif endif
	else
		OclUndefined.debug('Trace local variables can only be retrieved for variable expressions referring to rule variables')
	endif;

helper context OclAny def : isInApply : Boolean =
	let parent : OclAny = self.refImmediateComposite() in
	if parent.oclIsUndefined() then false
	else if parent.oclIsKindOf(ATL!Binding) then true
	else if parent.oclIsKindOf(ATL!RuleVariableDeclaration) then true
	else parent.isInApply
	endif endif endif;

helper context OclAny def : isInPostApply : Boolean =
	let parent : OclAny = self.refImmediateComposite() in
	if parent.oclIsUndefined() then false
	else if parent.oclIsKindOf(ATL!Statement) then true
	else parent.isInPostApply
	endif endif;

helper context ATL!Rule def : postloc : String =
	if self.actionBlock.oclIsUndefined() then
		self.location
	else
		self.actionBlock.location
	endif;

helper context ATL!Module def : calledRules : Sequence(ATL!CalledRule) =
	self.elements->select(e|e.oclIsKindOf(ATL!CalledRule));

helper context ATL!Rule def : outPatternElements : Sequence(ATL!OutPatternElement) =
	if self.outPattern.oclIsUndefined() then
		Sequence{}
	else
		self.outPattern.elements
	endif;

helper context ATL!Rule def : applyLoc : String =
	if self.outPattern.oclIsUndefined() then
		self.location
	else
		self.outPattern.location
	endif;

-- ======================================================================
-- helpers end
-- ======================================================================

-- ======================================================================
-- matched rules begin
-- ======================================================================

abstract rule Unit {
	from s : ATL!Unit in IN
	to t : EMFTVM!Module (
		name <- s.name,
		sourceName <- s.name + '.atl',
		imports <- s.libraries->collect(l|l.name),
		features <- Sequence{main}),
	   main : EMFTVM!Operation (
	   	name <- 'main',
		static <- true,
		"context" <- 'ExecEnv',
		contextModel <- 'EMFTVM',
		type <- 'java.lang.Object',
		typeModel <- '#native')
}

rule Library extends Unit {
	from s : ATL!Library in IN
	to t : EMFTVM!Module (
		features <- s.helpers->collect(h|h.definition)->append(main)),
	   main : EMFTVM!Operation
}

rule Query extends Unit {
	from s : ATL!Query in IN
	to t : EMFTVM!Module (
		features <- s.helpers->collect(h|h.definition)->append(main)),
	   main : EMFTVM!Operation (
	   	body <- s.body)
}

rule Module extends Unit {
	from s : ATL!Module in IN
	to t : EMFTVM!Module (
		inputModels <- s.inModels,
		outputModels <- s.outModels,
		features <- s.elements->select(e|e.oclIsKindOf(ATL!Helper))->collect(h|h.definition)
			->union(s.elements->select(e|e.oclIsKindOf(ATL!CalledRule)))
			->append(main),
		rules <- s.elements->select(e|e.oclIsKindOf(ATL!MatchedRule))),
	   main : EMFTVM!Operation (
	   	body <- body),
	   body : EMFTVM!CodeBlock (
	   	lineNumbers <- Sequence{ln}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.location.startLine,
		startColumn <- s.location.startColumn,
		endLine <- s.location.endLine,
		endColumn <- s.location.endColumn) 
}

rule ModuleWithEntryPoint extends Module {
	from s : ATL!Module in IN (
		s.calledRules->exists(r|r.isEntrypoint) and
		not s.calledRules->exists(r|r.isEndpoint))
	using {
		entryPointRule : ATL!CalledRule =
			s.calledRules->select(r|r.isEntrypoint)->first();
	}
	to t : EMFTVM!Module,
	   body : EMFTVM!CodeBlock (
		code <- Sequence{getenvtype_entry, invoke_entry}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{getenvtype_entry, invoke_entry}),
	   getenvtype_entry : EMFTVM!Getenvtype,							-- [ExecEnv]
	   invoke_entry : EMFTVM!InvokeStatic (							-- [result]
	   	opname <- entryPointRule.name,
		argcount <- 0),
	   pb : Problem!Problem (
	   	description <- 'Entrypoint rules are invoked after matched rules in EMFTVM',
		location <- entryPointRule.location,
		severity <- #warning)
}

rule ModuleWithEndPoint extends Module {
	from s : ATL!Module in IN (
		not s.calledRules->exists(r|r.isEntrypoint) and
		s.calledRules->exists(r|r.isEndpoint))
	using {
		endPointRule : ATL!CalledRule =
			s.calledRules->select(r|r.isEndpoint)->first();
	}
	to t : EMFTVM!Module,
	   body : EMFTVM!CodeBlock (
		code <- Sequence{getenvtype_end, invoke_end}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{getenvtype_end, invoke_end}),
	   getenvtype_end : EMFTVM!Getenvtype,								-- [ExecEnv]
	   invoke_end : EMFTVM!InvokeStatic (								-- [result]
	   	opname <- endPointRule.name,
		argcount <- 0)
}

rule ModuleWithEntryAndEndPoint extends Module {
	from s : ATL!Module in IN (
		s.calledRules->exists(r|r.isEntrypoint) and
		s.calledRules->exists(r|r.isEndpoint))
	using {
		entryPointRule : ATL!CalledRule =
			s.calledRules->select(r|r.isEntrypoint)->first();
		endPointRule : ATL!CalledRule =
			s.calledRules->select(r|r.isEndpoint)->first();
	}
	to t : EMFTVM!Module,
	   body : EMFTVM!CodeBlock (
		code <- Sequence{getenvtype_entry, invoke_entry, pop, getenvtype_end, invoke_end}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{getenvtype_entry, invoke_entry, pop, getenvtype_end, invoke_end}),
	   getenvtype_entry : EMFTVM!Getenvtype,							-- [ExecEnv]
	   invoke_entry : EMFTVM!InvokeStatic (							-- [result]
	   	opname <- entryPointRule.name,
		argcount <- 0),
	   pop : EMFTVM!Pop,												-- []
	   getenvtype_end : EMFTVM!Getenvtype,								-- [ExecEnv]
	   invoke_end : EMFTVM!InvokeStatic (								-- [result]
	   	opname <- endPointRule.name,
		argcount <- 0),
	   pb : Problem!Problem (
	   	description <- 'Entrypoint rules are invoked after matched rules in EMFTVM',
		location <- entryPointRule.location,
		severity <- #warning)
}

rule RefiningModule extends Module {
	from s : ATL!Module in IN (s.isRefining)
	to t : EMFTVM!Module,
	   pb : Problem!Problem (
	   	severity <- #error,
		description <- 'EMFTVM does not yet support refining mode',
		location <- s.location)
}

rule ModelDeclaration {
	from s : ATL!OclModel in IN (not s.metamodel.oclIsUndefined())
	to t : EMFTVM!ModelDeclaration (
		modelName <- s.name,
		metaModelName <- s.metamodel.name)
}

rule InPatternElement {
	from s : ATL!InPatternElement in IN
	to re : EMFTVM!InputRuleElement (
		name <- s.varName,
		type <- s.type.typeName,
		typeModel <- s.type.modelName,
		models <- s.models->collect(m|m.name)),
	   ov : EMFTVM!LocalVariable (
	   	name <- s.varName,
		type <- s.type.typeName,
		typeModel <- s.type.modelName)
}

rule InPatternElementWithFilter extends InPatternElement {
	from s : ATL!InPatternElement in IN (
		not s.inPattern.filter.oclIsUndefined())
	to re : EMFTVM!InputRuleElement,
	   lv : EMFTVM!LocalVariable (
	   	name <- s.varName,
		type <- s.type.typeName,
		typeModel <- s.type.modelName)
}

-- TODO multiple rule inheritance could have simplified this rule
rule InPatternElementWithFilterAndAction extends InPatternElementWithFilter {
	from s : ATL!InPatternElement in IN (
		not s.inPattern."rule".actionBlock.oclIsUndefined())
	to re : EMFTVM!InputRuleElement,
	   pv : EMFTVM!LocalVariable (
	   	name <- s.varName,
		type <- s.type.typeName,
		typeModel <- s.type.modelName)
}

rule InPatternElementWithoutFilterWithAction extends InPatternElement {
	from s : ATL!InPatternElement in IN (
		s.inPattern.filter.oclIsUndefined() and
		not s.inPattern."rule".actionBlock.oclIsUndefined())
	to re : EMFTVM!InputRuleElement,
	   pv : EMFTVM!LocalVariable (
	   	name <- s.varName,
		type <- s.type.typeName,
		typeModel <- s.type.modelName)
}

rule OutPatternElement {
	from s : ATL!OutPatternElement in IN (
		not s.outPattern."rule".oclIsKindOf(ATL!CalledRule))
	to re : EMFTVM!OutputRuleElement (
		name <- s.varName,
		type <- s.type.typeName,
		typeModel <- s.type.modelName,
		models <- Sequence{s.outModelName}),
	   ov : EMFTVM!LocalVariable (
	   	name <- s.varName,
		type <- s.type.typeName,
		typeModel <- s.type.modelName)
}

rule OutPatternElementWithMapsTo extends OutPatternElement {
	from s : ATL!OutPatternElement in IN (
		not s.sourceElement.oclIsUndefined() and
		s.outPattern."rule".actionBlock.oclIsUndefined())
	to re : EMFTVM!OutputRuleElement (
		"mapsTo" <- Sequence{thisModule.resolveTemp(s.sourceElement, 're')})
}

rule OutPatternElementWithAction extends OutPatternElement {
	from s : ATL!OutPatternElement in IN (
		not s.outPattern."rule".actionBlock.oclIsUndefined())
	to re : EMFTVM!OutputRuleElement,
	   pv : EMFTVM!LocalVariable (
	   	name <- s.varName,
		type <- s.type.typeName,
		typeModel <- s.type.modelName)
}

rule OutPatternElementWithActionAndMapsTo extends OutPatternElementWithAction {
	from s : ATL!OutPatternElement in IN (
		not s.sourceElement.oclIsUndefined())
	to re : EMFTVM!OutputRuleElement (
		"mapsTo" <- Sequence{thisModule.resolveTemp(s.sourceElement, 're')})
}

rule CalledRuleOutPatternElement {
	from s : ATL!OutPatternElement in IN (
		s.outPattern."rule".oclIsKindOf(ATL!CalledRule))
	to cb : EMFTVM!CodeBlock (
		lineNumbers <- Sequence{ln},
		code <- Sequence{findtype, new, store}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.location.startLine,
		startColumn <- s.location.startColumn,
		endLine <- s.location.endLine,
		endColumn <- s.location.endColumn,
		instructions <- Sequence{findtype, new, store}),
	   lv : EMFTVM!LocalVariable (
	   	name <- s.varName,
		type <- s.type.typeName,
		typeModel <- s.type.modelName),
	   findtype : EMFTVM!Findtype (											-- [type]
	   	modelname <- s.type.modelName,
		typename <- s.type.typeName),
	   new : EMFTVM!New (modelname <- s.outModelName),						-- [element]
	   store : EMFTVM!Store (localVariable <- lv)							-- []
}

rule CalledRuleVariableDeclaration {
	from s : ATL!RuleVariableDeclaration in IN (s."rule".oclIsKindOf(ATL!CalledRule))
	to lv : EMFTVM!LocalVariable (
		name <- s.varName,
		type <- s.type.typeName,
		typeModel <- s.type.modelName),
	   cb : EMFTVM!CodeBlock (
	   	lineNumbers <- Sequence{ln},
	   	nested <- Sequence{s.initExpression},
		code <- Sequence{invokeCb, store}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.location.startLine,
		startColumn <- s.location.startColumn,
		endLine <- s.location.endLine,
		endColumn <- s.location.endColumn,
		instructions <- Sequence{invokeCb, store}),
	   invokeCb : EMFTVM!InvokeCb (codeBlock <- s.initExpression, argcount <- 0),			-- [value]
	   store : EMFTVM!Store (localVariable <- s)											-- []
}

rule CalledRule { -- Called rules are really operations
	from s : ATL!CalledRule in IN
	to t : EMFTVM!Operation (
		name <- s.name,
		static <- true,
		"context" <- 'ExecEnv',
		contextModel <- 'EMFTVM',
		type <- 'java.lang.Object',
		typeModel <- '#native',
		parameters <- s.parameters,
		body <- body),
	   body : EMFTVM!CodeBlock (
	   	lineNumbers <- Sequence{ln},
		localVariables <- s.parameters->collect(p|thisModule.resolveTemp(p, 'lv'))
			->union(s.outPatternElements->collect(p|thisModule.resolveTemp(p, 'lv')))
			->union(s.variables),
		nested <- s.outPatternElements
			->union(s.variables->collect(v|thisModule.resolveTemp(v, 'cb')))
			->union(s.outPatternElements->collect(e|e.bindings)->flatten())
			->union(
				if s.actionBlock.oclIsUndefined() then
					Sequence{}
				else
					s.actionBlock.statements
				endif),
		code <- Sequence{invokeAllCbs}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.location.startLine,
		startColumn <- s.location.startColumn,
		endLine <- s.location.endLine,
		endColumn <- s.location.endColumn,
		instructions <- Sequence{invokeAllCbs}),
	   invokeAllCbs : EMFTVM!InvokeAllCbs					-- [null] * nestedCbSize
}

rule CalledRuleNamedMain extends CalledRule {
	from s : ATL!CalledRule in IN (s.name = 'main')
	to t : EMFTVM!Operation,
	   pb : Problem!Problem (
		description <- 'Called rules may not be named "main()"',
		location <- s.location,
		severity <- #error)
}

rule MatchedRuleVariableDeclaration {
	from s : ATL!RuleVariableDeclaration in IN (s."rule".oclIsKindOf(ATL!MatchedRule))
	to t : EMFTVM!Field (
		name <- s.varName,
		"context" <- 'TraceLink',
		contextModel <- 'TRACE',
		type <- s.type.typeName,
		typeModel <- s.type.modelName,
		initialiser <- init),
	   init : EMFTVM!CodeBlock, -- Empty initialiser
	   cb : EMFTVM!CodeBlock (
	   	lineNumbers <- Sequence{ln},
	   	nested <- Sequence{s.initExpression},
		code <- Sequence{invokeCb, load, set}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.location.startLine,
		startColumn <- s.location.startColumn,
		endLine <- s.location.endLine,
		endColumn <- s.location.endColumn,
		instructions <- Sequence{invokeCb, load, set}),
	   invokeCb : EMFTVM!InvokeCb (codeBlock <- s.initExpression, argcount <- 0),			-- [value]
	   load : EMFTVM!Load (localVariable <- thisModule.resolveTemp(s."rule", 'a_trace')),	-- [trace, value]
	   set : EMFTVM!"Set" (fieldname <- s.varName)											-- []
}

rule MatchedRule {
	from s : ATL!MatchedRule in IN
	to t : EMFTVM!Rule (
		name <- s.name,
		"abstract" <- s.isAbstract,
		superRules <- if s.superRule.oclIsUndefined() then Sequence{} else Sequence{s.superRule.name} endif,
		outputElements <- s.outPatternElements,
		mode <- 
			if s.oclIsKindOf(ATL!LazyMatchedRule) then
				#manual
			else
				#automaticSingle -- TODO support refining rules
			endif,
		default <-
			if s.oclIsKindOf(ATL!LazyMatchedRule) then
				s.isUnique
			else
				not s.isNoDefault
			endif,
		distinctElements <- false,
		inputElements <- s.inPattern.elements,
		fields <- s.variables,
		applier <- a),
	   a : EMFTVM!CodeBlock (
	   	lineNumbers <- Sequence{aln},
	   	localVariables <- Sequence{a_trace}
			->union(s.inPattern.elements->collect(e|thisModule.resolveTemp(e, 'ov')))
			->union(s.outPatternElements->collect(e|thisModule.resolveTemp(e, 'ov'))),
		nested <- s.variables->collect(v|thisModule.resolveTemp(v, 'cb'))
			->union(s.outPatternElements->collect(e|e.bindings)->flatten()),
	   	code <- Sequence{a_invokeAllCbs}),
	   aln : EMFTVM!LineNumber (
	   	startLine <- s.applyLoc.startLine,
		startColumn <- s.applyLoc.startColumn,
		endLine <- s.applyLoc.endLine,
		endColumn <- s.applyLoc.endColumn,
		instructions <- Sequence{a_invokeAllCbs}),
	   a_trace : EMFTVM!LocalVariable (
	   	name <- '__trace__',
		type <- 'TraceLink',
		typeModel <- 'TRACE'),
	   a_invokeAllCbs : EMFTVM!InvokeAllCbs					-- [null] * nestedCbSize
}

rule MatchedRuleWithFilter extends MatchedRule {
	from s : ATL!MatchedRule in IN (
		not s.inPattern.filter.oclIsUndefined())
	using {
		matchLoc : String = s.inPattern.filter.location;
	}
	to t : EMFTVM!Rule (
		matcher <- m),
	   m : EMFTVM!CodeBlock (
	   	lineNumbers <- Sequence{mln},
	   	localVariables <- s.inPattern.elements->collect(e|thisModule.resolveTemp(e, 'lv')),
	   	nested <- Sequence{s.inPattern.filter},
	   	code <- Sequence{invokeCb}),
	   mln : EMFTVM!LineNumber (
	   	startLine <- matchLoc.startLine,
		startColumn <- matchLoc.startColumn,
		endLine <- matchLoc.endLine,
		endColumn <- matchLoc.endColumn,
	   	instructions <- Sequence{invokeCb}),
	   invokeCb : EMFTVM!InvokeCb  (codeBlock <- s.inPattern.filter)
}

-- TODO This rule could have been simplified with multiple inheritance
rule MatchedRuleWithFilterAndAction extends MatchedRuleWithFilter {
	from s : ATL!MatchedRule in IN (
		not s.actionBlock.oclIsUndefined())
	using {
		postLoc : String = s.actionBlock.location;
	}
	to t : EMFTVM!Rule (
		postApply <- p),
	   p : EMFTVM!CodeBlock (
	   	localVariables <- Sequence{p_trace}
			->union(s.inPattern.elements->collect(e|thisModule.resolveTemp(e, 'pv')))
			->union(s.outPatternElements->collect(e|thisModule.resolveTemp(e, 'pv'))),
	   	lineNumbers <- Sequence{pln},
	   	nested <- s.actionBlock.statements,
		code <- Sequence{p_invokeAllCbs}),
	   p_trace : EMFTVM!LocalVariable (
	   	name <- '__trace__',
	   	type <- 'TraceLink',
		typeModel <- 'TRACE'),
	   pln : EMFTVM!LineNumber (
	   	startLine <- postLoc.startLine,
		startColumn <- postLoc.startColumn,
		endLine <- postLoc.endLine,
		endColumn <- postLoc.endColumn,
		instructions <- Sequence{p_invokeAllCbs}),
	   p_invokeAllCbs : EMFTVM!InvokeAllCbs					-- [value] * nestedCbSize
}

rule MatchedRuleWithoutFilterWithAction extends MatchedRule {
	from s : ATL!MatchedRule in IN (
		s.inPattern.filter.oclIsUndefined() and
		not s.actionBlock.oclIsUndefined())
	using {
		postLoc : String = s.actionBlock.location;
	}
	to t : EMFTVM!Rule (
		postApply <- p),
	   p : EMFTVM!CodeBlock (
	   	localVariables <- Sequence{p_trace}
			->union(s.inPattern.elements->collect(e|thisModule.resolveTemp(e, 'pv')))
			->union(s.outPatternElements->collect(e|thisModule.resolveTemp(e, 'pv'))),
	   	lineNumbers <- Sequence{pln},
	   	nested <- s.actionBlock.statements,
		code <- Sequence{p_invokeAllCbs}),
	   p_trace : EMFTVM!LocalVariable (
	   	name <- '__trace__',
	   	type <- 'TraceLink',
		typeModel <- 'TRACE'),
	   pln : EMFTVM!LineNumber (
	   	startLine <- postLoc.startLine,
		startColumn <- postLoc.startColumn,
		endLine <- postLoc.endLine,
		endColumn <- postLoc.endColumn,
		instructions <- Sequence{p_invokeAllCbs}),
	   p_invokeAllCbs : EMFTVM!InvokeAllCbs					-- [value] * nestedCbSize
}

rule Binding {
	from s : ATL!Binding in IN
	to cb : EMFTVM!CodeBlock (
		lineNumbers <- Sequence{ln},
		nested <- Sequence{s.value},
		code <- Sequence{invokeCb, invoke, load, set}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.location.startLine,
		startColumn <- s.location.startColumn,
		endLine <- s.location.endLine,
		endColumn <- s.location.endColumn,
		instructions <- Sequence{invokeCb, invoke, load, set}),
	   invokeCb : EMFTVM!InvokeCb (codeBlock <- s.value, argcount <- 0),	-- [value]
	   invoke : EMFTVM!Invoke (opname <- 'resolve', argcount <- 0),			-- [rvalue]
	   load : EMFTVM!Load (
	   	localVariable <-													-- [lv, rvalue]
			if s.parentRule.oclIsKindOf(ATL!MatchedRule) then
				thisModule.resolveTemp(s.outPatternElement, 'ov')
			else
				thisModule.resolveTemp(s.outPatternElement, 'lv')
			endif),
	   set : EMFTVM!"Set" (fieldname <- s.propertyName)						-- []
}

-------------- Statements -----------------

rule ExpressionStat {
	from s : ATL!ExpressionStat in IN
	to cb : EMFTVM!CodeBlock (
		lineNumbers <- Sequence{ln},
		nested <- Sequence{s.expression},
		code <- Sequence{invokeCb}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.location.startLine,
		startColumn <- s.location.startColumn,
		endLine <- s.location.endLine,
		endColumn <- s.location.endColumn,
		instructions <- Sequence{invokeCb}),
	   invokeCb : EMFTVM!InvokeCb (codeBlock <- s.expression, argcount <- 0)		-- [value]
}

rule NonLastExpressionStat extends ExpressionStat {
	from s : ATL!ExpressionStat in IN (
		not s.refImmediateComposite().oclIsKindOf(ATL!ActionBlock) or
		s.refImmediateComposite().statements->last() <> s)
	to cb : EMFTVM!CodeBlock (
		code <- Sequence{invokeCb, pop}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{invokeCb, pop}),
	   invokeCb : EMFTVM!InvokeCb,												-- [value]
	   pop : EMFTVM!Pop															-- []
}

rule BindingStat {
	from s : ATL!BindingStat in IN (not s.isAssignment)
	to cb : EMFTVM!CodeBlock (
		lineNumbers <- Sequence{ln},
		nested <- Sequence{s.source, s.value},
		code <- Sequence{invokeCb, invoke, invokeCb2, set}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.location.startLine,
		startColumn <- s.location.startColumn,
		endLine <- s.location.endLine,
		endColumn <- s.location.endColumn,
		instructions <- Sequence{invokeCb, invoke, invokeCb2, set}),
	   invokeCb : EMFTVM!InvokeCb (codeBlock <- s.value, argcount <- 0),		-- [value]
	   invoke : EMFTVM!Invoke (opname <- 'resolve', argcount <- 0),				-- [rvalue]
	   invokeCb2 : EMFTVM!InvokeCb (codeBlock <- s.source, argcount <- 0),		-- [source, rvalue]
	   set : EMFTVM!"Set" (fieldname <- s.propertyName)							-- []
}

rule AssignmentBindingStat {
	from s : ATL!BindingStat in IN (s.isAssignment)
	to cb : EMFTVM!CodeBlock (
		lineNumbers <- Sequence{ln},
		nested <- Sequence{s.source, s.value},
		code <- Sequence{invokeCb, invokeCb2, set}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.location.startLine,
		startColumn <- s.location.startColumn,
		endLine <- s.location.endLine,
		endColumn <- s.location.endColumn,
		instructions <- Sequence{invokeCb, invokeCb2, set}),
	   invokeCb : EMFTVM!InvokeCb (codeBlock <- s.value, argcount <- 0),		-- [value]
	   invokeCb2 : EMFTVM!InvokeCb (codeBlock <- s.source, argcount <- 0),		-- [source, value]
	   set : EMFTVM!"Set" (fieldname <- s.propertyName)							-- []
}

abstract rule IfStat {
	from s : ATL!IfStat in IN
	to cb : EMFTVM!CodeBlock (
		lineNumbers <- Sequence{ln}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.location.startLine,
		startColumn <- s.location.startColumn,
		endLine <- s.location.endLine,
		endColumn <- s.location.endColumn),
	   invokeCb : EMFTVM!InvokeCb (codeBlock <- s.condition, argcount <- 0)		-- [cond]
}

rule IfStatWithThenAndElse extends IfStat {
	from s : ATL!IfStat in IN (s.thenStatements->notEmpty() and s.elseStatements->notEmpty())
	to cb : EMFTVM!CodeBlock (
		lineNumbers <- Sequence{ln},
		nested <- Sequence{s.condition, thenCb, elseCb},
		code <- Sequence{invokeCb, ifn, invokeThen, goto, invokeElse}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.location.startLine,
		startColumn <- s.location.startColumn,
		endLine <- s.location.endLine,
		endColumn <- s.location.endColumn,
		instructions <- Sequence{invokeCb, ifn, invokeThen, goto, invokeElse}),
	   invokeCb : EMFTVM!InvokeCb (codeBlock <- s.condition, argcount <- 0),		-- [cond]
	   ifn : EMFTVM!Ifn (target <- goto),											-- []
	   invokeThen : EMFTVM!InvokeCb (codeBlock <- thenCb, argcount <- 0),			-- [...]
	   goto : EMFTVM!Goto (target <- invokeElse),									-- [...]
	   invokeElse : EMFTVM!InvokeCb (codeBlock <- elseCb, argcount <- 0),			-- [...]
	   thenCb : EMFTVM!CodeBlock (
	   	nested <- s.thenStatements,
		code <- Sequence{invokeAllCbs}),
	   invokeAllCbs : EMFTVM!InvokeAllCbs (argcount <- 0),
	   elseCb : EMFTVM!CodeBlock (
	   	nested <- s.elseStatements,
		code <- Sequence{invokeAllCbs2}),
	   invokeAllCbs2 : EMFTVM!InvokeAllCbs (argcount <- 0)
}

rule IfStatWithThen extends IfStat {
	from s : ATL!IfStat in IN (s.thenStatements->notEmpty() and s.elseStatements->isEmpty())
	to cb : EMFTVM!CodeBlock (
		lineNumbers <- Sequence{ln},
		nested <- Sequence{s.condition, thenCb},
		code <- Sequence{invokeCb, ifn, invokeThen}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.location.startLine,
		startColumn <- s.location.startColumn,
		endLine <- s.location.endLine,
		endColumn <- s.location.endColumn,
		instructions <- Sequence{invokeCb, ifn, invokeThen}),
	   invokeCb : EMFTVM!InvokeCb (codeBlock <- s.condition, argcount <- 0),		-- [cond]
	   ifn : EMFTVM!Ifn (target <- invokeThen),										-- []
	   invokeThen : EMFTVM!InvokeCb (codeBlock <- thenCb, argcount <- 0),			-- [...]
	   thenCb : EMFTVM!CodeBlock (
	   	nested <- s.thenStatements,
		code <- Sequence{invokeAllCbs}),
	   invokeAllCbs : EMFTVM!InvokeAllCbs (argcount <- 0)
}

rule IfStatWithElse extends IfStat {
	from s : ATL!IfStat in IN (s.thenStatements->isEmpty() and s.elseStatements->notEmpty())
	to cb : EMFTVM!CodeBlock (
		lineNumbers <- Sequence{ln},
		nested <- Sequence{s.condition, elseCb},
		code <- Sequence{invokeCb, ift, invokeElse}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.location.startLine,
		startColumn <- s.location.startColumn,
		endLine <- s.location.endLine,
		endColumn <- s.location.endColumn,
		instructions <- Sequence{invokeCb, ift, invokeElse}),
	   invokeCb : EMFTVM!InvokeCb (codeBlock <- s.condition, argcount <- 0),		-- [cond]
	   ift : EMFTVM!If (target <- invokeElse),										-- []
	   invokeElse : EMFTVM!InvokeCb (codeBlock <- elseCb, argcount <- 0),			-- [...]
	   elseCb : EMFTVM!CodeBlock (
	   	nested <- s.elseStatements,
		code <- Sequence{invokeAllCbs2}),
	   invokeAllCbs2 : EMFTVM!InvokeAllCbs (argcount <- 0)
}

rule IfStatWithNothing extends IfStat {
	from s : ATL!IfStat in IN (s.thenStatements->isEmpty() and s.elseStatements->isEmpty())
	to cb : EMFTVM!CodeBlock (
		lineNumbers <- Sequence{ln},
		nested <- Sequence{s.condition},
		code <- Sequence{invokeCb, pop}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.location.startLine,
		startColumn <- s.location.startColumn,
		endLine <- s.location.endLine,
		endColumn <- s.location.endColumn,
		instructions <- Sequence{invokeCb, pop}),
	   invokeCb : EMFTVM!InvokeCb (codeBlock <- s.condition, argcount <- 0),		-- [cond]
	   pop : EMFTVM!Pop 															-- []
}

rule ForStat {
	from s : ATL!ForStat in IN
	to cb : EMFTVM!CodeBlock (
		localVariables <- Sequence{s.iterator},
		lineNumbers <- Sequence{ln},
		nested <- Sequence{s.collection, loop},
		code <- Sequence{invokeCb, it, store, invokeCb2, endit}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.location.startLine,
		startColumn <- s.location.startColumn,
		endLine <- s.location.endLine,
		endColumn <- s.location.endColumn,
		instructions <- Sequence{invokeCb, it, store, invokeCb2, endit}),
	   invokeCb : EMFTVM!InvokeCb (codeBlock <- s.collection, argcount <- 0),		-- [coll]
	   it : EMFTVM!Iterate (target <- endit),										-- [value, it(coll)]
	   store : EMFTVM!Store (localVariable <- s.iterator),							-- [it(coll)]
	   invokeCb2 : EMFTVM!InvokeCb (codeBlock <- loop),								-- [it(coll)]
	   endit : EMFTVM!Enditerate (target <- it),									-- []
	   loop : EMFTVM!CodeBlock (
	   	nested <- s.statements,
		code <- Sequence{invokeAllCbs}),
	   invokeAllCbs : EMFTVM!InvokeAllCbs (argcount <- 0)
}

-- ======================================================================
-- matched rules end
-- ======================================================================
