<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
		<title>ATL Developer Guide - ATL Language</title>
		<link type="text/css" rel="stylesheet" href="book.css"/>
	</head>
	<body>
		<table class="navigation" style="width: 100%;" border="0" summary="navigation">
			<tr>
				<th style="width: 100%" align="center" colspan="3">ATL Language</th>
			</tr>
			<tr>
				<td style="width: 20%" align="left">
					<a href="ATL-Plugins.html" title="ATL Plugins">
						<img alt="Previous" border="0" src="images/images/prev.gif"/>
					</a>
				</td>
				<td style="width: 60%" align="center"></td>
				<td style="width: 20%" align="right">
					<a href="ATL-Core-API.html" title="ATL Core API">
						<img alt="Next" border="0" src="images/images/next.gif"/>
					</a>
				</td>
			</tr>
			<tr>
				<td style="width: 20%" align="left" valign="top">ATL Plugins</td>
				<td style="width: 60%" align="center"></td>
				<td style="width: 20%" align="right" valign="top">ATL Core API</td>
			</tr>
		</table><hr/>
		<h1 id="ATL_Language">ATL Language</h1>
		<h2 id="Overview_2">Overview</h2>
		<p>ATL language which can be split into two parts :</p>
		<ul>
			<li>declarative : matched rules, and called rules body. The main use of ATL is declarative. Imperative part should only be used in specific cases.</li>
			<li>imperative : called rules (imperatively called), and action blocks ("do", usable in any rules)</li>
		</ul>
		<p>Specifics uses of those parts are described in the 
			<a href="http://wiki.eclipse.org/ATL_Language_Troubleshooter">ATL Language Troubleshooter</a> section.
		</p>
		<p>ATL architecture is composed of four main components : </p>
		<ul>
			<li>ATL Editor</li>
			<li>
				<a href="ATL-Language.html#Parsing_and_Compilation">ATL Compiler</a>
			</li>
			<li>
				<a href="ATL-VM.html#ATL_VM">ATL VM</a>
			</li>
			<li>
				<a href="ATL-VM.html#Model_Handlers">Model handlers</a>
			</li>
		</ul>
		<p>ATL VM is intercalated between the ATL compiler and the used frameworks (EMF, MDR), allowing modularity. Consequently, changes on ATL Language only involve ATL compiler.
			The following schema describes ATL components and their role during the execution of a transformation.</p>
		<p>
			<img border="0" src="images/ATL_compilation_process.JPG"/>
		</p>
		<h2 id="Parsing_and_Compilation">Parsing and Compilation</h2>
		<p>ATL parsing is done using a parser defined in TCS, which outputs an ATL model conforming to the ATL metamodel. Then, an ATL-WFR transformation (interpreted by the engine) generates a problem model. This model produces errors interpreted by the editor and translated into markers, visible on the ATL file on each compilation.</p>
		<p>Two versions of the ATL compiler are available : 2004 and 
			<a href="http://wiki.eclipse.org/ATL_2006">2006</a>.
			The 2006 version of ATL compiler uses 
			<a href="ACG-ATL-VM-Code-Generator-.html#ACG_.28ATL_VM_Code_Generator.29">ACG</a>. The 2004 version uses ATP, the historical ACG predecessor.
		</p>
		<h2 id="Debugger">Debugger</h2>
		<p>The ATL Debugger provides tools to support profiling, debugging, etc... of ATL applications. It can be compared to the 
			<a href="http://java.sun.com/javase/6/docs/technotes/guides/jvmti/">JVM TI</a>.
		</p>
		<p>In ATL, three debuggers are implemented :</p>
		<ul>
			<li>DummyDebugger : a dummy class implementing the debugger interface without doing anything.</li>
			<li>SimpleDebugger</li>
			<li>NetworkDebugger</li>
		</ul>
		<p>In the ATL VM code, debugger entry points are located into exec methods of operations, materialized by "step" method calls.</p>
		<h3 id="SimpleDebugger">SimpleDebugger</h3>
		<p>The simple debugger is the default ATL debugger : it displays in Eclipse's console the informations traced by the ATL VM during the execution.
			A "very verbose" option allows to display all possible informations traced by the ATL VM frames, intending to debug the ATL VM. Many options are available, for example :</p>
		<ul>
			<li>step : stop point  at every 
				<a href="#ASM_format_bytecode">ASM_format bytecode</a> instruction
			</li>
			<li>stepops : list of operations for which we want to display bytecode</li>
			<li>deepstepops : same than stepops, also including sub-called operations</li>
		</ul>
		<h3 id="NetworkDebugger">NetworkDebugger</h3>
		<p>The network debugger is the main debugger of ATL, integrated to Eclipse's debug perspective. It uses ADWP, a TCP debugger inspired on JDWP (the java debugger). All debug informations are sent on a TCP port by the executed program (Local). Those informations are received and computed by the debugger (Remote), implemented in the org.eclipse.m2m.atl.adt.debug plugin.</p>
		<p>The disassembly mode allows to debug the bytecode, without ATL source code, and make easier to debug the ATL VM.</p><hr/>
		<table class="navigation" style="width: 100%;" border="0" summary="navigation">
			<tr>
				<td style="width: 20%" align="left">
					<a href="ATL-Plugins.html" title="ATL Plugins">
						<img alt="Previous" border="0" src="images/images/prev.gif"/>
					</a>
				</td>
				<td style="width: 60%" align="center">
					<a href="ATL Developer Guide.html" title="ATL Developer Guide">
						<img alt="ATL Developer Guide" border="0" src="images/images/home.gif"/>
					</a>
				</td>
				<td style="width: 20%" align="right">
					<a href="ATL-Core-API.html" title="ATL Core API">
						<img alt="Next" border="0" src="images/images/next.gif"/>
					</a>
				</td>
			</tr>
			<tr>
				<td style="width: 20%" align="left" valign="top">ATL Plugins</td>
				<td style="width: 60%" align="center"></td>
				<td style="width: 20%" align="right" valign="top">ATL Core API</td>
			</tr>
		</table>
	</body>
</html>